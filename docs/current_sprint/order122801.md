# 작업 명령서 - Multi-Provider OAuth 지원

## 1. 기본 정보

| 항목 | 내용 |
|------|------|
| **날짜** | 2025-12-28 (Asia/Tokyo) |
| **Base Commit** | 79389875a43cf32c1d62ae212e23e02adcb509a9 |
| **작성자** | Claude Code |

## 2. 사용자 오더 (원문)

> database users table의 수정과 유저 정보 취급 방법의 변경
> - google_id 항목을 provider, provider_id항목으로 분리함
> provider : google, naver, line, apple등 인증 프로바이더의종류
> provider_id : 현재의 구글 id, 각 프로바이더가 제공하는 id
>
> unique 체크(프로바이더로 구분되어 동일 id가 들어올수 있는점)등 변경에 따른 사이드 이펙트를 예상하고 대안을 만들어라
>
> 변경후 기존에 사용하는 프로젝트에서 사용법을 수정하게 하기 위한 설명이 필요

## 3. 변경 요약

1. `google_id` 컬럼을 `provider` + `provider_id` 복합 컬럼으로 분리
2. 복합 UNIQUE 제약 조건 적용 및 인덱스 재구성
3. 동일 이메일 다중 프로바이더 연동 정책 결정 및 구현

## 4. 개요 및 Task 목표

### 배경

현재 auth-service는 Google OAuth만 지원하며, `users` 테이블의 `google_id` 컬럼에 Google 사용자 ID를 저장합니다. 향후 Naver, Line, Apple 등 다른 OAuth 프로바이더를 지원하기 위해 데이터베이스 스키마와 관련 코드를 범용적으로 변경해야 합니다.

### 목표

1. **스키마 범용화**: `google_id` → `provider`, `provider_id`로 분리
2. **데이터 무결성**: 프로바이더별 고유성 보장 (복합 UNIQUE)
3. **하위 호환성**: 기존 Google 사용자 데이터 마이그레이션
4. **확장성**: 새로운 프로바이더 추가 시 DB 변경 없이 코드만 추가

### 현재 구조

```sql
-- 현재 스키마
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    google_id VARCHAR(255) UNIQUE NOT NULL,  -- 변경 대상
    email VARCHAR(255) UNIQUE NOT NULL,
    ...
);
```

```typescript
// 현재 코드
interface User {
  google_id: string;
  // ...
}

findUserByGoogleId(googleId: string): Promise<User | null>
createUser(googleId: string, email: string, ...): Promise<User>
```

### 변경 후 구조

```sql
-- 변경 후 스키마
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    provider VARCHAR(50) NOT NULL,     -- 'google', 'naver', 'line', 'apple'
    provider_id VARCHAR(255) NOT NULL, -- 각 프로바이더의 user ID
    email VARCHAR(255) NOT NULL,       -- UNIQUE 제약 제거 (옵션)
    ...
    CONSTRAINT unique_provider_user UNIQUE (provider, provider_id)
);
```

```typescript
// 변경 후 코드
type AuthProvider = 'google' | 'naver' | 'line' | 'apple';

interface User {
  provider: AuthProvider;
  provider_id: string;
  // ...
}

findUserByProvider(provider: AuthProvider, providerId: string): Promise<User | null>
createUser(provider: AuthProvider, providerId: string, email: string, ...): Promise<User>
```

## 5. 사용자 오더에 대한 문제점 및 설계 결정

### 5.1 동일 이메일로 다중 프로바이더 가입 문제

**문제**: 같은 이메일을 사용하는 사용자가 Google과 Naver로 각각 가입하면?

**옵션 분석**:

| 옵션 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **A. 이메일 UNIQUE 유지** | 먼저 가입한 프로바이더만 허용 | 단순, 1인 1계정 보장 | 사용자 혼란 가능 |
| **B. 이메일 UNIQUE 제거** | 프로바이더별 별도 계정 | 유연성 | 동일인 중복 계정 발생 |
| **C. 계정 연동** | 동일 이메일은 기존 계정에 프로바이더 추가 | 최적 UX | 구현 복잡도 증가 |

**권장안**: **옵션 A (이메일 UNIQUE 유지)**

- 이유: 현재 프로젝트 특성상 1인 1계정이 적합
- 사용자가 다른 프로바이더로 로그인 시도 시 "이미 {provider}로 가입된 이메일입니다" 안내

### 5.2 기존 데이터 마이그레이션

**문제**: 기존 `google_id` 데이터를 새 스키마로 안전하게 이전해야 함

**해결**:

```sql
-- 마이그레이션 스크립트
ALTER TABLE users ADD COLUMN provider VARCHAR(50);
ALTER TABLE users ADD COLUMN provider_id VARCHAR(255);

UPDATE users SET provider = 'google', provider_id = google_id;

ALTER TABLE users ALTER COLUMN provider SET NOT NULL;
ALTER TABLE users ALTER COLUMN provider_id SET NOT NULL;
ALTER TABLE users ADD CONSTRAINT unique_provider_user UNIQUE (provider, provider_id);

ALTER TABLE users DROP COLUMN google_id;
```

### 5.3 인덱스 전략

**현재**:

```sql
CREATE INDEX idx_users_google_id ON users(google_id);
```

**변경 후**:

```sql
-- 복합 인덱스 (검색용)
CREATE INDEX idx_users_provider_provider_id ON users(provider, provider_id);
-- 프로바이더별 통계용
CREATE INDEX idx_users_provider ON users(provider);
```

## 6. 범위 및 산출물

### In Scope

- [x] 데이터베이스 스키마 변경
- [x] 마이그레이션 스크립트 작성
- [x] Backend 코드 수정 (queries, passport, jwt, types)
- [x] API 응답 형식 변경 (필요시)
- [x] 기존 사용자 마이그레이션 가이드

### Out of Scope

- [ ] Naver, Line, Apple OAuth 실제 구현 (별도 작업)
- [ ] Frontend 변경 (프로바이더 표시 UI)
- [ ] 계정 연동 기능

### 산출물

1. 마이그레이션 SQL 스크립트
2. 변경된 TypeScript 코드
3. 사용자 마이그레이션 가이드 문서

## 7. 변경 파일 목록

### Database (A: 추가)

| 상태 | 파일 | 설명 |
|------|------|------|
| A | `database/migrations/001_multi_provider.sql` | 스키마 마이그레이션 스크립트 |

### Database (M: 수정)

| 상태 | 파일 | 설명 |
|------|------|------|
| M | `database/schema.sql` | provider, provider_id 컬럼, 복합 UNIQUE 제약 조건 |

### Backend (M: 수정)

| 상태 | 파일 | 설명 |
|------|------|------|
| M | `backend/src/db/queries.ts` | User 인터페이스, findUserByProvider(), createUser() 변경 |
| M | `backend/src/services/passport.ts` | findUserByGoogleId → findUserByProvider 호출 변경 |
| M | `backend/src/services/jwt.ts` | JwtPayload에 provider 필드 추가 (옵션) |
| M | `backend/src/types/express.d.ts` | Express.User 타입 변경 |

### Documentation (A/M)

| 상태 | 파일 | 설명 |
|------|------|------|
| A | `docs/MIGRATION_GUIDE.md` | 기존 프로젝트 마이그레이션 가이드 |
| M | `docs/BACKEND_STRUCTURE.md` | 변경된 구조 반영 |

## 8. 구현 계획

### Phase 1: 스키마 변경 준비

1. 마이그레이션 스크립트 작성 (`001_multi_provider.sql`)
2. 롤백 스크립트 작성

### Phase 2: 코드 변경

1. `AuthProvider` 타입 정의
2. `User` 인터페이스 변경
3. `findUserByProvider()` 함수 구현
4. `findUserByGoogleId()` deprecated 처리 후 내부에서 `findUserByProvider('google', id)` 호출
5. `createUser()` 시그니처 변경
6. Passport 전략 코드 수정
7. Express.User 타입 업데이트

### Phase 3: 테스트 및 마이그레이션

1. 단위 테스트 업데이트
2. 로컬 환경 마이그레이션 테스트
3. 기존 기능 회귀 테스트

### 설계 의도

```typescript
// 하위 호환성을 위한 deprecated 함수 유지
/**
 * @deprecated Use findUserByProvider('google', googleId) instead
 */
export async function findUserByGoogleId(googleId: string): Promise<User | null> {
  return findUserByProvider('google', googleId);
}
```

## 9. 테스트 플랜

### 자동화 테스트 (AI 수행)

| 테스트 | 검증 내용 |
|--------|----------|
| 단위 테스트 | `findUserByProvider()` 정상 동작 |
| 단위 테스트 | `createUser()` 새 시그니처 동작 |
| 통합 테스트 | Google OAuth 로그인 플로우 |
| 마이그레이션 테스트 | 기존 데이터 정상 변환 |
| TypeScript 빌드 | 타입 오류 없음 |

### 수동 테스트 (사용자 수행)

| 테스트 | 검증 내용 |
|--------|----------|
| E2E 테스트 | 실제 Google 로그인 |
| 데이터 확인 | DB에서 provider='google' 확인 |
| 권한 테스트 | Admin 기능 정상 동작 |

## 10. 실행/검증 결과

> Phase 구현 완료 후 기록

| 단계 | 명령어 | 결과 | 비고 |
|------|--------|------|------|
| 마이그레이션 | `psql -f migrations/001_multi_provider.sql` | - | |
| 빌드 | `npm run build` | - | |
| 테스트 | `npm test` | - | |

## 11. 작업 순서

### Phase 1: 스키마 및 마이그레이션

- [ ] 1.1 `database/migrations/` 폴더 생성
- [ ] 1.2 `001_multi_provider.sql` 마이그레이션 스크립트 작성
- [ ] 1.3 `database/schema.sql` 업데이트
- [ ] **검증**: 마이그레이션 스크립트 문법 확인

### Phase 2: Backend 코드 변경

- [ ] 2.1 `queries.ts` - AuthProvider 타입 및 User 인터페이스 변경
- [ ] 2.2 `queries.ts` - `findUserByProvider()` 함수 추가
- [ ] 2.3 `queries.ts` - `findUserByGoogleId()` deprecated 처리
- [ ] 2.4 `queries.ts` - `createUser()` 시그니처 변경
- [ ] 2.5 `passport.ts` - Google Strategy 코드 수정
- [ ] 2.6 `express.d.ts` - 타입 정의 업데이트
- [ ] **검증**: `npm run build` 성공

### Phase 3: 테스트 업데이트

- [ ] 3.1 기존 테스트 수정 (queries 관련)
- [ ] 3.2 새 함수 테스트 추가
- [ ] **검증**: `npm test` 성공

### Phase 4: 문서화

- [ ] 4.1 `MIGRATION_GUIDE.md` 작성
- [ ] 4.2 `BACKEND_STRUCTURE.md` 업데이트
- [ ] **검증**: 문서 리뷰

### Phase 5: 로컬 마이그레이션 테스트

- [ ] 5.1 로컬 DB 백업
- [ ] 5.2 마이그레이션 실행
- [ ] 5.3 애플리케이션 테스트
- [ ] **검증**: Google 로그인 정상 동작

## 12. 리스크 및 롤백

### 리스크

| 리스크 | 영향도 | 대응책 |
|--------|--------|--------|
| 마이그레이션 실패 | 높음 | 트랜잭션 처리, 롤백 스크립트 준비 |
| 기존 사용자 로그인 불가 | 높음 | deprecated 함수로 하위 호환성 유지 |
| 성능 저하 | 중간 | 복합 인덱스로 최적화 |

### 롤백 스크립트

```sql
-- 롤백: 001_multi_provider_rollback.sql
ALTER TABLE users ADD COLUMN google_id VARCHAR(255);
UPDATE users SET google_id = provider_id WHERE provider = 'google';
ALTER TABLE users ALTER COLUMN google_id SET NOT NULL;
ALTER TABLE users ADD CONSTRAINT users_google_id_key UNIQUE (google_id);

ALTER TABLE users DROP CONSTRAINT unique_provider_user;
ALTER TABLE users DROP COLUMN provider;
ALTER TABLE users DROP COLUMN provider_id;

DROP INDEX IF EXISTS idx_users_provider_provider_id;
DROP INDEX IF EXISTS idx_users_provider;
CREATE INDEX idx_users_google_id ON users(google_id);
```

## 13. Known Issues / TODO

### Known Issues

- 동일 이메일 다중 프로바이더 가입 시 첫 번째 프로바이더만 허용 (의도된 동작)

### Future TODO

- [ ] Naver OAuth 프로바이더 추가
- [ ] Line OAuth 프로바이더 추가
- [ ] Apple OAuth 프로바이더 추가
- [ ] 계정 연동 기능 (동일 이메일 다중 프로바이더 연결)
- [ ] 프로바이더별 로그인 통계 대시보드

---

## 부록: 기존 프로젝트 마이그레이션 가이드

### 1. 데이터베이스 마이그레이션

```bash
# 1. 백업
pg_dump -h localhost -U postgres auth > backup_$(date +%Y%m%d).sql

# 2. 마이그레이션 실행
psql -h localhost -U postgres -d auth -f database/migrations/001_multi_provider.sql
```

### 2. 코드 변경 사항

#### Before (기존)

```typescript
import { findUserByGoogleId, createUser } from './db/queries';

// 사용자 조회
const user = await findUserByGoogleId(googleId);

// 사용자 생성
const newUser = await createUser(googleId, email, name, pictureUrl);

// 타입
interface User {
  google_id: string;
}
```

#### After (변경 후)

```typescript
import { findUserByProvider, createUser, AuthProvider } from './db/queries';

// 사용자 조회
const user = await findUserByProvider('google', providerId);

// 사용자 생성
const newUser = await createUser('google', providerId, email, name, pictureUrl);

// 타입
interface User {
  provider: AuthProvider;
  provider_id: string;
}
```

### 3. Breaking Changes

| 변경 항목 | Before | After |
|----------|--------|-------|
| User.google_id | `string` | 삭제됨 |
| User.provider | - | `'google' \| 'naver' \| 'line' \| 'apple'` |
| User.provider_id | - | `string` |
| findUserByGoogleId() | 사용 | deprecated → findUserByProvider() |
| createUser() | `(googleId, email, ...)` | `(provider, providerId, email, ...)` |

### 4. 호환성 유지 기간

- `findUserByGoogleId()` 함수는 **3개월간** deprecated로 유지
- 이후 버전에서 완전 제거 예정
